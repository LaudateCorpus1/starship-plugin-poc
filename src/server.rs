use futures::{future, StreamExt};
use service::{Plugin, init_tracing};
use std::{
    net::{IpAddr, Ipv6Addr, SocketAddr},
    process::{Command, Stdio},
};
use tarpc::{
    context,
    serde_transport::tcp,
    server::{self, Channel, Incoming},
};
use tokio_serde::formats::Bincode;

#[derive(Clone)]
struct PluginServer(SocketAddr);

#[tarpc::server]
impl Plugin for PluginServer {
    async fn hello(self, _: context::Context, name: String) -> String {
        println!("Message from {}", name);
        format!("Hello, {}!", name)
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    init_tracing("Starship Plugin Server")?;

    let plugins = vec!["./target/debug/client"];

    let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), 0);

    let mut listener = tcp::listen(&server_addr, Bincode::default).await?;
    listener.config_mut().max_frame_length(usize::MAX);
    println!("Listening to {:?}", listener.local_addr());

    for plugin in plugins {
        Command::new(plugin)
            .arg(listener.local_addr().port().to_string())
            .stdin(Stdio::null())
            // .stdout(Stdio::null())
            // .stderr(Stdio::null())
            .spawn()?;
    }

    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated Plugin trait.
        .map(|channel| {
            let server = PluginServer(channel.transport().peer_addr().unwrap());
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;

    Ok(())
}
